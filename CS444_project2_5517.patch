2c2,6
<  * elevator noop
---
> 	 * Below is the LOOK IO elevator scheduler
> 	 * The structure is based off the NOOP scheduluer in 
> 	 * 	linux-yocto-3.19/block/noop-iosched.c
> 	 * This website is VERY helpful in understanding the API calls in this
> 		 code: http://www.cse.unsw.edu.au/~aaronc/iosched/doc/api/index.html
11,13d14
< struct noop_data {
< 	struct list_head queue;
< };
15c16,33
< static void noop_merged_requests(struct request_queue *q, struct request *rq,
---
> /*
>  	* sector_t is the type used for indexing onto a disc or disc partition.
> 		Linux always considers sectors to be 512 bytes long independently
> 		of the devices real block size.
> 
> 	* typedef u64 sector_t;
> */
> struct look_data {
> 	struct list_head queue; //head pointer to circularly linked list
> 	int direction;
> 	sector_t disk_head;
> };
> /*
> 	* Called when two requests have been turned into a single request. 
> 		This occurs when a request grows (as a result of a bio merge) 
> 		to become adjacent with an existing request.
> */
> static void look_merged_requests(struct request_queue *req_q, struct request *cur_req,
20,30c38,91
< 
< static int noop_dispatch(struct request_queue *q, int force)
< {
< 	struct noop_data *nd = q->elevator->elevator_data;
< 
< 	if (!list_empty(&nd->queue)) {
< 		struct request *rq;
< 		rq = list_entry(nd->queue.next, struct request, queuelist);
< 		list_del_init(&rq->queuelist);
< 		elv_dispatch_sort(q, rq);
< 		return 1;
---
> /*
> 	* Requests the scheduler to populate the dispatch queue 
> 		with requests. Once requests have been dispatched, 
> 		the scheduler may not manipulate them. 
> 	* Returns the number of requests dispatched.
> */
> static int look_dispatch(struct request_queue *req_q, int force)
> {
> 	struct look_data *look = req_q->elevator->elevator_data;
> 	struct request *next_req, *prev_req, *cur_req;
> 	if (!list_empty(&look->queue)){
> 		next_req = list_entry(look->queue.next, struct request, queuelist);
> 		prev_req = list_entry(look->queue.prev, struct request, queuelist);	
> 		cur_req = next_req; //in case there's only one req in queue
> 
> 		/*If this is the first move for the disk_head, make it frwd*/
> 		if(look->direction != 1 && == look->direction0){
> 			look->direction = 1;
> 		}
> 		/*If we're moving forward*/
> 		if(look->direction == 1){
> 			/*If there is another req in this direction take it*/
> 			if(blk_rq_pos(next_req) >= look->disk_head){
> 				cur_req = next_req;
> 			}
> 			/*Change direction if there's no more reqs in fwrd direction
> 			  	Note how this traverses the list backwards instead of simply
> 				following the circularl list to the front again. This is what
> 				differentiates this LOOK scheduler from the C-LOOK
> 			*/			
> 			else{
> 				look->direction = 0;
> 				cur_req = prev_req; //turn around
> 			}
> 		}
> 		/*Else we're moving backward*/
> 		else{
> 			/*If there is another req in this direction take it*/			
> 			if(blk_rq_pos(prev_req) < look->disk_head){
> 				cur_req = prev_req;
> 			}
> 			/*Change direction if there's no more reqs in back direction*/
> 			else{
> 				look->direction = 1;
> 				cur_req = next_req; //turn around
> 			}
> 		}
> 		/*Assert that cur_req is valid*/
> 		if(cur_req){	
> 			look->disk_head = blk_rq_pos(cur_req) + blk_rq_sectors(cur_req); //move head
> 			list_del_init(&cur_req->queuelist); //remove the cur_req from scheduler
> 			elv_dispatch_add_tail(req_q, cur_req); //add cur_req to the block's queue
> 			return 1;
> 		}
31a93
> 	/*No requests*/
34,39c96,126
< 
< static void noop_add_request(struct request_queue *q, struct request *rq)
< {
< 	struct noop_data *nd = q->elevator->elevator_data;
< 
< 	list_add_tail(&rq->queuelist, &nd->queue);
---
> /*
> 	* Queues a new request with the scheduler.
> 	* 1) Check if the run queue is empty
> 			Yes --> add the cur_req
> 	* 2) If its not
> 			Loop until cur_req's correct position is found
> 			Insert cur_req there		
> */
> static void look_add_request(struct request_queue *req_q, struct request *cur_req)
> {
> 	struct look_data *look = req_q->elevator->elevator_data;
> 	/*init head_ptr to beginning of queue in case its empty*/
> 	struct request *next_req, 
> 				   *prev_req, 
> 				   *head_ptr = look;
> 
> 	if(!list_empty(&look->queue)){
> 		next_req = list_entry(look->queue.next, struct request, queuelist);
> 		prev_req = list_entry(look->queue.prev, struct request, queuelist);
> 		/*traverse the queue looking for where to place the cur_req	*/
> 		while(blk_rq_pos(cur_req) >= blk_rq_pos(next)){
> 			/*list_entry() gets the struct for the given entry*/
> 			next_req = list_entry(next_req->queuelist.next, struct request, queuelist);
> 			prev_req = list_entry(prev_req->queuelist.prev, struct request, queuelist);
> 		}
> 		/*insert the cur_req ahead of the prev_req and behind the next_req*/
> 		head_ptr = prev_que;
> 	}
> 	if(head_ptr){
> 		list_add(&cur_req->queuelist, &head_ptr->queuelist);
> 	}
41c128,133
< 
---
> /*
> 	* Returns the request BEFORE the current req in start-sector order. 
> 		Used to discover opportunities to place two adjacent 
> 		requests next to eachother (i.e. drop two 
> 		people off at same floor).
> */
43c135
< noop_former_request(struct request_queue *q, struct request *rq)
---
> look_former_request(struct request_queue *req_q, struct request *cur_req)
45c137
< 	struct noop_data *nd = q->elevator->elevator_data;
---
> 	struct look_data *look = req_q->elevator->elevator_data;
47c139
< 	if (rq->queuelist.prev == &nd->queue)
---
> 	if (cur_req->queuelist.prev == &look->queue)
49c141
< 	return list_entry(rq->queuelist.prev, struct request, queuelist);
---
> 	return list_entry(cur_req->queuelist.prev, struct request, queuelist);
51c143,148
< 
---
> /*
> 	* Returns the request AFTER the current req in start-sector order. 
> 		Used to discover opportunities to place two adjacent 
> 		requests next to eachother (i.e. drop two 
> 		people off at same floor).
> */
53c150
< noop_latter_request(struct request_queue *q, struct request *rq)
---
> look_latter_request(struct request_queue *req_q, struct request *cur_req)
55c152
< 	struct noop_data *nd = q->elevator->elevator_data;
---
> 	struct look_data *look = req_q->elevator->elevator_data;
57c154
< 	if (rq->queuelist.next == &nd->queue)
---
> 	if (cur_req->queuelist.next == &look->queue)
59c156
< 	return list_entry(rq->queuelist.next, struct request, queuelist);
---
> 	return list_entry(cur_req->queuelist.next, struct request, queuelist);
61,62c158,161
< 
< static int noop_init_queue(struct request_queue *q, struct elevator_type *e)
---
> /*
> 	* Initialize a scheduler instance
> */
> static int look_init_queue(struct request_queue *req_q, struct elevator_type *e)
64,65c163,164
< 	struct noop_data *nd;
< 	struct elevator_queue *eq;
---
> 	struct look_data *look;
> 	struct elevator_queue *elev_q;
67,68c166,167
< 	eq = elevator_alloc(q, e);
< 	if (!eq)
---
> 	elev_q = elevator_alloc(req_q, e);
> 	if (!elev_q)
71,73c170,172
< 	nd = kmalloc_node(sizeof(*nd), GFP_KERNEL, q->node);
< 	if (!nd) {
< 		kobject_put(&eq->kobj);
---
> 	look = kmalloc_node(sizeof(*look), GFP_KERNEL, req_q->node);
> 	if (!look) {
> 		kobject_put(&elev_q->kobj);
76c175
< 	eq->elevator_data = nd;
---
> 	elev_q->elevator_data = look;
78c177
< 	INIT_LIST_HEAD(&nd->queue);
---
> 	INIT_LIST_HEAD(&look->queue);
80,82c179,181
< 	spin_lock_irq(q->queue_lock);
< 	q->elevator = eq;
< 	spin_unlock_irq(q->queue_lock);
---
> 	spin_lock_irq(req_q->queue_lock);
> 	req_q->elevator = elev_q;
> 	spin_unlock_irq(req_q->queue_lock);
85,94c184,200
< 
< static void noop_exit_queue(struct elevator_queue *e)
< {
< 	struct noop_data *nd = e->elevator_data;
< 
< 	BUG_ON(!list_empty(&nd->queue));
< 	kfree(nd);
< }
< 
< static struct elevator_type elevator_noop = {
---
> /*
> 	* Clean up scheduler instance
> */
> static void look_exit_queue(struct elevator_queue *e)
> {
> 	struct look_data *look = e->elevator_data;
> 
> 	BUG_ON(!list_empty(&look->queue));
> 	kfree(look);
> }
> /*
> 	* Have the built in elevator functions point to our
> 		implemented functions
> */
> static struct elevator_type elevator_look = {
> 	.elevator_name = "LOOK ELEVATOR",
> 	.elevator_owner = THIS_MODULE,	
96,102c202,208
< 		.elevator_merge_req_fn		= noop_merged_requests,
< 		.elevator_dispatch_fn		= noop_dispatch,
< 		.elevator_add_req_fn		= noop_add_request,
< 		.elevator_former_req_fn		= noop_former_request,
< 		.elevator_latter_req_fn		= noop_latter_request,
< 		.elevator_init_fn		= noop_init_queue,
< 		.elevator_exit_fn		= noop_exit_queue,
---
>         .elevator_merge_req_fn = look_merged_requests,
>         .elevator_dispatch_fn = look_dispatch,
>         .elevator_add_req_fn = look_add_request,
> 		.elevator_former_req_fn = look_former_request,
>         .elevator_latter_req_fn = look_latter_request,
>         .elevator_init_fn = look_init_queue,
>         .elevator_exit_fn = look_exit_queue,
104,105d209
< 	.elevator_name = "noop",
< 	.elevator_owner = THIS_MODULE,
107,108c211,214
< 
< static int __init noop_init(void)
---
> /*
> 	* Register our LOOK elevator
> */
> static int __init look_init(void)
110c216
< 	return elv_register(&elevator_noop);
---
> 	return elv_register(&elevator_look);
112,113c218,221
< 
< static void __exit noop_exit(void)
---
> /*
> 	* On exit, unregister out LOOK Elevator
> */
> static void __exit look_exit(void)
115c223
< 	elv_unregister(&elevator_noop);
---
> 	elv_unregister(&elevator_look);
118,124c226,227
< module_init(noop_init);
< module_exit(noop_exit);
< 
< 
< MODULE_AUTHOR("Jens Axboe");
< MODULE_LICENSE("GPL");
< MODULE_DESCRIPTION("No-op IO scheduler");
---
> module_init(look_init);
> module_exit(look_exit);
\ No newline at end of file
