\documentclass[draftclsnofoot, onecolumn, 10pt, compsoc]{IEEEtran}

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[top=0.75in, bottom=0.75in, left=0.75in, right=0.75in]{geometry}

\title{\textbf{Operating Systems II}\\Fall 2017\\Homework 3}

\author{Omeed Habibelahian\\Jeremy Fischer\\Group 17}

\begin{document}
	\maketitle
	\newpage
	
	\section{Design}
	\section{Version Control Log}
	\section{Work Log}
	\section{Questions}
		\subsection{Main Point of the Assignment}
			The main point of this assignment was to understand how to present a chunk of memory as a block device, as well as to familiarize ourselves with the Linux Kernel's Crypto API and learn how to use this API to enable encryption and decryption of data on our block device.
		\subsection{Our Approach}
		\subsection{Ensuring Correctness}
			To ensure that the block device and the encryption/decryption code are acting as expected, we've added \textit{printk()} statements throughout the code. Once the qemu environment is booted, check the output of the \textit{printk()} statements by typing \textit{dmesg} in the command line or by viewing \textit{/var/log/messages}. The \textit{printk()} statements we've included indicate whether the device is reading or writing data, whether the block device was successfully initiated, and whether or not an initialization failure occurred anywhere in the code.
		\subsection{What We Learned}
		\subsection{How to Evaluate and Prove Correctness}
			\textbf{Steps to Run with Patch}
			\begin{enumerate}
				\item git clone "git://git.yoctoproject.org/linux-yocto-3.19" linux-yocto-3.19-patched
				\item Apply Patch
				\begin{enumerate}
					\item cp KernelAssn3.patch linux-yocto-3.19-patched/block
					\item cd linux-yocto-3.19-patched/block
					\item patch $<$ kernelAssn3.patch
				\end{enumerate}
				\item cd ..
				\item cp /scratch/files/config-3.19.2-yocto-standard .
				\item make menuconfig
				\item Save and Exit
				\item make -j4 all
				\item cd ..
				\item Use \textit{screen} command to create two split-screens.
				\item In both screens, make sure to source the environment variable.
				\begin{enumerate}
					\item \textbf{SCREEN 1:}
						qemu-system-i386 -gdb tcp::5517 -S -nographic -kernel bzImage-qemux86.bin -drive file=core-image-lsb-sdk-qemux86.ext4,if=ide -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/hda rw console=ttyS0 debug"
					\item \textbf{SCREEN 2:} \$GDB
					\item \textbf{SCREEN 2:} target remote :5517
					\item \textbf{SCREEN 2:} continue
					\item \textbf{SCREEN 1:} log in as root
					\item \textbf{SCREEN 1:}
					\item \textbf{SCREEN 1:}
					\item \textbf{SCREEN 1:}
					\item \textbf{SCREEN 1:}
				\end{enumerate}
				\item If no output from the \textit{printk()} statements can be seen from the dmesg command, when reboot is entered you will see output.
				\item reboot (this stops qemu)
			\end{enumerate}
	
%	Below are notes about the project...
%	\begin{enumerate}
%		\item Write a RAM disk device driver that registers it as block device
%		\item Using the crypto API, add encryption to the block device such that the device driver encrypts and decrypts data when it is written and read
%		\item This will be developed in the drivers/block directory
%		\item This will need to be a module, in order to use a module parameter.
%		\item The module must then be moved in to the running VM. Kevin recommends scp.
%		\item This is a block cypher, there may be more data than fits in one block of the cypher.
%		\item The key must be set as a module parameter
%		\item An incorrect key must produce gibberish
%		\item Create an ext2 file system on the block device (mkfs.ext2).
%	\end{enumerate}
	
\end{document}